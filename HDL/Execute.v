/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



module DIG_Sub #(
    parameter Bits = 2
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits-1):0] s,
    output c_o
);
    wire [Bits:0] temp;

    assign temp = a - b - c_i;
    assign s = temp[(Bits-1):0];
    assign c_o = temp[Bits];
endmodule


module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule


module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule


module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module Mux_2x1
(
    input [0:0] sel,
    input in_0,
    input in_1,
    output reg out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module Execute (
  input [15:0] L,
  input [15:0] R,
  input [1:0] result_mux,
  input [1:0] logic_instr,
  input sub,
  input beq,
  output [15:0] O,
  output Flag_zero,
  output Flag_OVR
);
  wire [15:0] s0;
  wire [15:0] s1;
  wire [15:0] s2;
  wire [15:0] s3;
  wire [15:0] s4;
  wire [15:0] s5;
  wire [15:0] s6;
  wire s7;
  DIG_Add #(
    .Bits(16)
  )
  DIG_Add_i0 (
    .a( L ),
    .b( R ),
    .c_i( 1'b0 ),
    .s( s0 )
  );
  assign s2 = (R ^ L);
  assign s4 = (R & L);
  assign s5 = (R | L);
  DIG_Sub #(
    .Bits(16)
  )
  DIG_Sub_i1 (
    .a( L ),
    .b( R ),
    .c_i( 1'b0 ),
    .s( s6 ),
    .c_o( Flag_OVR )
  );
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i2 (
    .sel( result_mux ),
    .in_0( L ),
    .in_1( R ),
    .in_2( s0 ),
    .in_3( L ),
    .out( s1 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i3 (
    .a( s6 ),
    .b( 16'b0 ),
    .\= ( s7 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i4 (
    .sel( sub ),
    .in_0( s1 ),
    .in_1( s6 ),
    .out( s3 )
  );
  Mux_2x1 Mux_2x1_i5 (
    .sel( beq ),
    .in_0( 1'b0 ),
    .in_1( s7 ),
    .out( Flag_zero )
  );
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i6 (
    .sel( logic_instr ),
    .in_0( s3 ),
    .in_1( s4 ),
    .in_2( s5 ),
    .in_3( s2 ),
    .out( O )
  );
endmodule
