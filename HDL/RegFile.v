/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module Decoder2 (
    output out_0,
    output out_1,
    output out_2,
    output out_3,
    input [1:0] sel
);
    assign out_0 = (sel == 2'h0)? 1'b1 : 1'b0;
    assign out_1 = (sel == 2'h1)? 1'b1 : 1'b0;
    assign out_2 = (sel == 2'h2)? 1'b1 : 1'b0;
    assign out_3 = (sel == 2'h3)? 1'b1 : 1'b0;
endmodule


module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module DemuxBus2
#(
    parameter Bits = 2,
    parameter Default = 0 
)
(
    output [(Bits-1):0] out_0,
    output [(Bits-1):0] out_1,
    output [(Bits-1):0] out_2,
    output [(Bits-1):0] out_3,
    input [1:0] sel,
    input [(Bits-1):0] in
);
    assign out_0 = (sel == 2'h0)? in : Default;
    assign out_1 = (sel == 2'h1)? in : Default;
    assign out_2 = (sel == 2'h2)? in : Default;
    assign out_3 = (sel == 2'h3)? in : Default;
endmodule


module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule


module RegFile (
  input [1:0] rs,
  input clock,
  input [1:0] rd,
  input [15:0] result,
  input load,
  input [15:0] load_data,
  output [15:0] R0,
  output [15:0] R1,
  output [15:0] R2,
  output [15:0] R3,
  output [15:0] RR,
  output [15:0] RL
);
  wire [15:0] s0;
  wire [15:0] s1;
  wire [15:0] s2;
  wire [15:0] s3;
  wire [15:0] s4;
  wire s5;
  wire [15:0] R1_temp;
  wire s6;
  wire [15:0] R0_temp;
  wire s7;
  wire [15:0] R2_temp;
  wire s8;
  wire [15:0] R3_temp;
  Decoder2 Decoder2_i0 (
    .sel( rd ),
    .out_0( s6 ),
    .out_1( s5 ),
    .out_2( s7 ),
    .out_3( s8 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i1 (
    .sel( load ),
    .in_0( result ),
    .in_1( load_data ),
    .out( s4 )
  );
  DemuxBus2 #(
    .Bits(16),
    .Default(0)
  )
  DemuxBus2_i2 (
    .sel( rd ),
    .in( s4 ),
    .out_0( s0 ),
    .out_1( s1 ),
    .out_2( s2 ),
    .out_3( s3 )
  );
  // R1
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i3 (
    .D( s1 ),
    .C( clock ),
    .en( s5 ),
    .Q( R1_temp )
  );
  // R0
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i4 (
    .D( s0 ),
    .C( clock ),
    .en( s6 ),
    .Q( R0_temp )
  );
  // R2
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i5 (
    .D( s2 ),
    .C( clock ),
    .en( s7 ),
    .Q( R2_temp )
  );
  // R3
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i6 (
    .D( s3 ),
    .C( clock ),
    .en( s8 ),
    .Q( R3_temp )
  );
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i7 (
    .sel( rs ),
    .in_0( R0_temp ),
    .in_1( R1_temp ),
    .in_2( R2_temp ),
    .in_3( R3_temp ),
    .out( RR )
  );
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i8 (
    .sel( rd ),
    .in_0( R0_temp ),
    .in_1( R1_temp ),
    .in_2( R2_temp ),
    .in_3( R3_temp ),
    .out( RL )
  );
  assign R0 = R0_temp;
  assign R1 = R1_temp;
  assign R2 = R2_temp;
  assign R3 = R3_temp;
endmodule
