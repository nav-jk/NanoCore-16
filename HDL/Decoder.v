/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module Decoder3 (
    output out_0,
    output out_1,
    output out_2,
    output out_3,
    output out_4,
    output out_5,
    output out_6,
    output out_7,
    input [2:0] sel
);
    assign out_0 = (sel == 3'h0)? 1'b1 : 1'b0;
    assign out_1 = (sel == 3'h1)? 1'b1 : 1'b0;
    assign out_2 = (sel == 3'h2)? 1'b1 : 1'b0;
    assign out_3 = (sel == 3'h3)? 1'b1 : 1'b0;
    assign out_4 = (sel == 3'h4)? 1'b1 : 1'b0;
    assign out_5 = (sel == 3'h5)? 1'b1 : 1'b0;
    assign out_6 = (sel == 3'h6)? 1'b1 : 1'b0;
    assign out_7 = (sel == 3'h7)? 1'b1 : 1'b0;
endmodule


module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule

module PriorityEncoder2 (
    input in0,
    input in1,
    input in2,
    input in3,
    output reg [1:0] num,
    output any
);
    always @ (*) begin
        if (in3 == 1'b1)
            num = 2'h3;
        else if (in2 == 1'b1)
            num = 2'h2;
        else if (in1 == 1'b1)
            num = 2'h1;
        else 
            num = 2'h0;
    end

    assign any = in0 | in1 | in2 | in3;
endmodule


module Decoder (
  input [31:0] instr,
  input [15:0] RR,
  input [15:0] RL,
  output [1:0] rs,
  output [1:0] rd,
  output add,
  output [15:0] L,
  output [15:0] R,
  output jump,
  output move,
  output [1:0] result_mux,
  output load,
  output store,
  output [3:0] address,
  output [1:0] logic_instr,
  output sub,
  output beq,
  output tworeg,
  output [4:0] op
);
  wire [15:0] s0;
  wire [1:0] logic_instr_temp;
  wire [2:0] s1;
  wire tworeg_temp;
  wire add_temp;
  wire beq_temp;
  wire move_temp;
  wire jump_temp;
  wire s2;
  wire [4:0] s3;
  wire [4:0] s4;
  wire [1:0] s5;
  assign s0 = instr[15:0];
  assign rd = instr[17:16];
  assign rs = instr[21:20];
  assign logic_instr_temp = instr[23:22];
  assign s1 = instr[26:24];
  assign tworeg_temp = instr[27];
  assign address = instr[31:28];
  Decoder3 Decoder3_i0 (
    .sel( s1 ),
    .out_0( add_temp ),
    .out_1( beq_temp ),
    .out_2( sub ),
    .out_4( store ),
    .out_5( load ),
    .out_6( move_temp ),
    .out_7( jump_temp )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i1 (
    .sel( tworeg_temp ),
    .in_0( s0 ),
    .in_1( RR ),
    .out( R )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i2 (
    .sel( tworeg_temp ),
    .in_0( RR ),
    .in_1( RL ),
    .out( L )
  );
  assign s3[2:0] = s1;
  assign s3[4:3] = 2'b0;
  assign s4[2:0] = 3'b1;
  assign s4[4:3] = logic_instr_temp;
  assign s5 = (logic_instr_temp | 2'b0);
  PriorityEncoder2 PriorityEncoder2_i3 (
    .in0( jump_temp ),
    .in1( add_temp ),
    .in2( move_temp ),
    .in3( beq_temp ),
    .num( result_mux )
  );
  assign s2 = (s5[0] | s5[1]);
  Mux_2x1_NBits #(
    .Bits(5)
  )
  Mux_2x1_NBits_i4 (
    .sel( s2 ),
    .in_0( s3 ),
    .in_1( s4 ),
    .out( op )
  );
  assign add = add_temp;
  assign jump = jump_temp;
  assign move = move_temp;
  assign logic_instr = logic_instr_temp;
  assign beq = beq_temp;
  assign tworeg = tworeg_temp;
endmodule
