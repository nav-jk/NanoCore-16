/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
module PriorityEncoder3 (
    input in0,
    input in1,
    input in2,
    input in3,
    input in4,
    input in5,
    input in6,
    input in7,
    output reg [2:0] num,
    output any
);
    always @ (*) begin
        if (in7 == 1'b1)
            num = 3'h7;
        else if (in6 == 1'b1)
            num = 3'h6;
        else if (in5 == 1'b1)
            num = 3'h5;
        else if (in4 == 1'b1)
            num = 3'h4;
        else if (in3 == 1'b1)
            num = 3'h3;
        else if (in2 == 1'b1)
            num = 3'h2;
        else if (in1 == 1'b1)
            num = 3'h1;
        else 
            num = 3'h0;
    end

    assign any = in0 | in1 | in2 | in3 | in4 | in5 | in6 | in7;
endmodule


module Assembler (
  input mode,
  input [15:0] value,
  input [1:0] dest,
  input [1:0] src,
  input add,
  input jump,
  input tworeg,
  input move,
  input load,
  input store,
  input [3:0] address,
  input [1:0] logic_instr,
  input logic_en,
  input sub,
  input beq,
  output [31:0] inst,
  output store_clk
);
  wire [2:0] s0;
  wire s1;
  PriorityEncoder3 PriorityEncoder3_i0 (
    .in0( add ),
    .in1( beq ),
    .in2( sub ),
    .in3( logic_en ),
    .in4( store ),
    .in5( load ),
    .in6( move ),
    .in7( jump ),
    .num( s0 ),
    .any( s1 )
  );
  assign inst[15:0] = value;
  assign inst[17:16] = dest;
  assign inst[19:18] = 2'b0;
  assign inst[21:20] = src;
  assign inst[23:22] = logic_instr;
  assign inst[26:24] = s0;
  assign inst[27] = tworeg;
  assign inst[31:28] = address;
  assign store_clk = (s1 & mode);
endmodule
